From a496fbc8802f0a5719db6347a43cc869e03d83c9 Mon Sep 17 00:00:00 2001
From: Alan Modra <amodra@gmail.com>
Date: Sat, 25 Jul 2015 16:38:42 +0930
Subject: [PATCH] Fix broken -Bsymbolic-functions

For selected targets.  The testcase reveals a number of targets that
still need fixing.

bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Use SYMBOLIC_BIND to
	check if a symbol should be bound symbolically.
	* elf32-hppa.c (elf32_hppa_check_relocs,
	elf32_hppa_adjust_dynamic_symbol, elf32_hppa_relocate_section,
	elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs,
	elf_m68k_relocate_section): Likewise.
	* elf32-nios2.c (nios2_elf32_relocate_section,
	nios2_elf32_check_relocs, allocate_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol,
	elf32_tic6x_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/symbolic-func.s,
	* ld-elf/symbolic-func.r: New test.
	* ld-elf/elf.exp: Run it.
---
 bfd/ChangeLog                       | 14 ++++++++++++++
 bfd/elf32-arm.c                     |  2 +-
 bfd/elf32-hppa.c                    |  8 ++++----
 bfd/elf32-m68k.c                    |  4 ++--
 bfd/elf32-nios2.c                   |  6 +++---
 bfd/elf32-tic6x.c                   |  4 ++--
 ld/testsuite/ChangeLog              |  6 ++++++
 ld/testsuite/ld-elf/elf.exp         | 10 +++++++++-
 ld/testsuite/ld-elf/symbolic-func.r | 18 ++++++++++++++++++
 ld/testsuite/ld-elf/symbolic-func.s | 13 +++++++++++++
 10 files changed, 72 insertions(+), 13 deletions(-)
 create mode 100644 ld/testsuite/ld-elf/symbolic-func.r
 create mode 100644 ld/testsuite/ld-elf/symbolic-func.s

diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
index 919df17..367dff3 100644
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -8449,7 +8449,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	  else if (h != NULL
 		   && h->dynindx != -1
 		   && (!info->shared
-		       || !info->symbolic
+		       || !SYMBOLIC_BIND (info, h)
 		       || !h->def_regular))
 	    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
 	  else
diff --git a/bfd/elf32-hppa.c b/bfd/elf32-hppa.c
index af512a7..f611e0d 100644
--- a/bfd/elf32-hppa.c
+++ b/bfd/elf32-hppa.c
@@ -1467,7 +1467,7 @@ elf32_hppa_check_relocs (bfd *abfd,
 	       && (sec->flags & SEC_ALLOC) != 0
 	       && (IS_ABSOLUTE_RELOC (r_type)
 		   || (hh != NULL
-		       && (!info->symbolic
+		       && (!SYMBOLIC_BIND (info, &hh->eh)
 			   || hh->eh.root.type == bfd_link_hash_defweak
 			   || !hh->eh.def_regular))))
 	      || (ELIMINATE_COPY_RELOCS
@@ -1819,7 +1819,7 @@ elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,
 	  || (eh->def_regular
 	      && eh->root.type != bfd_link_hash_defweak
 	      && ! hppa_elf_hash_entry (eh)->plabel
-	      && (!info->shared || info->symbolic)))
+	      && (!info->shared || SYMBOLIC_BIND (info, eh))))
 	{
 	  /* The .plt entry is not needed when:
 	     a) Garbage collection has removed all references to the
@@ -4005,7 +4005,7 @@ elf32_hppa_relocate_section (bfd *output_bfd,
 		       && (plabel
 			   || !IS_ABSOLUTE_RELOC (r_type)
 			   || !info->shared
-			   || !info->symbolic
+			   || !SYMBOLIC_BIND (info, &hh->eh)
 			   || !hh->eh.def_regular))
 		{
 		  outrel.r_info = ELF32_R_INFO (hh->eh.dynindx, r_type);
@@ -4389,7 +4389,7 @@ elf32_hppa_finish_dynamic_symbol (bfd *output_bfd,
 	 global offset table will already have been initialized in the
 	 relocate_section function.  */
       if (info->shared
-	  && (info->symbolic || eh->dynindx == -1)
+	  && (SYMBOLIC_BIND (info, eh) || eh->dynindx == -1)
 	  && eh->def_regular)
 	{
 	  rela.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
diff --git a/bfd/elf32-m68k.c b/bfd/elf32-m68k.c
index fad3ec6..db0d0da 100644
--- a/bfd/elf32-m68k.c
+++ b/bfd/elf32-m68k.c
@@ -2758,7 +2758,7 @@ elf_m68k_check_relocs (bfd *abfd,
 	  if (!(info->shared
 		&& (sec->flags & SEC_ALLOC) != 0
 		&& h != NULL
-		&& (!info->symbolic
+		&& (!SYMBOLIC_BIND (info, h)
 		    || h->root.type == bfd_link_hash_defweak
 		    || !h->def_regular)))
 	    {
@@ -4027,7 +4027,7 @@ elf_m68k_relocate_section (bfd *output_bfd,
 			   || r_type == R_68K_PC16
 			   || r_type == R_68K_PC32
 			   || !info->shared
-			   || !info->symbolic
+			   || !SYMBOLIC_BIND (info, h)
 			   || !h->def_regular))
 		{
 		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
diff --git a/bfd/elf32-nios2.c b/bfd/elf32-nios2.c
index e5b7763..a5ab54f 100644
--- a/bfd/elf32-nios2.c
+++ b/bfd/elf32-nios2.c
@@ -4398,7 +4398,7 @@ nios2_elf32_relocate_section (bfd *output_bfd,
 		  else if (h != NULL
 			   && h->dynindx != -1
 			   && (!info->shared
-			       || !info->symbolic
+			       || !SYMBOLIC_BIND (info, h)
 			       || !h->def_regular))
 		    {
 		      outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
@@ -4909,7 +4909,7 @@ nios2_elf32_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	      && (sec->flags & SEC_ALLOC) != 0
 	      && (r_type == R_NIOS2_BFD_RELOC_32
 		  || (h != NULL && ! h->needs_plt
-		      && (! info->symbolic || ! h->def_regular))))
+		      && (! SYMBOLIC_BIND (info, h) || ! h->def_regular))))
 	    {
 	      struct elf32_nios2_dyn_relocs *p;
 	      struct elf32_nios2_dyn_relocs **head;
@@ -5752,7 +5752,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)
   if (info->shared)
     {
       if (h->def_regular
-	  && (h->forced_local || info->symbolic))
+	  && (h->forced_local || SYMBOLIC_BIND (info, h)))
 	{
 	  struct elf32_nios2_dyn_relocs **pp;
 
diff --git a/bfd/elf32-tic6x.c b/bfd/elf32-tic6x.c
index 8bfad84..7fc385b 100644
--- a/bfd/elf32-tic6x.c
+++ b/bfd/elf32-tic6x.c
@@ -1849,7 +1849,7 @@ elf32_tic6x_finish_dynamic_symbol (bfd * output_bfd,
          The entry in the global offset table will already have been
          initialized in the relocate_section function.  */
       if (info->shared
-	  && (info->symbolic
+	  && (SYMBOLIC_BIND (info, h)
 	      || h->dynindx == -1 || h->forced_local) && h->def_regular)
 	{
 	  asection *s = h->root.u.def.section;
@@ -2449,7 +2449,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
 	      else if (h != NULL
 		       && h->dynindx != -1
 		       && (!info->shared
-			   || !info->symbolic
+			   || !SYMBOLIC_BIND (info, h)
 			   || !h->def_regular))
 		{
 		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
diff --git a/ld/testsuite/ld-elf/elf.exp b/ld/testsuite/ld-elf/elf.exp
index d1a70ea..55bcb72 100644
--- a/ld/testsuite/ld-elf/elf.exp
+++ b/ld/testsuite/ld-elf/elf.exp
@@ -77,7 +77,7 @@ if { ![istarget hppa64*-hpux*] } {
     }
 }
 
-# Only run these tests on targets thats support creating shared libraries.
+# Only run these tests on targets that support creating shared libraries.
 if { [check_shared_lib_support] } then {
     # Run a test to check linking a shared library with a broken linker
     # script that accidentally marks dynamic sections as notes.  The
@@ -107,6 +107,14 @@ if { [check_shared_lib_support] } then {
 	    "--as-needed" "--start-group tmpdir/pr17068a.a tmpdir/pr17068.so tmpdir/pr17068b.a --end-group" ""
 	    {start.s pr17068.s} {} "pr17068"}
     }
+    # xfail on tic6x due to non-PIC/non-PID warnings
+    setup_xfail "tic6x-*-*"
+    run_ld_link_tests {
+	{"-Bsymbolic-functions"
+	    "-shared -Bsymbolic-functions" "" ""
+	    {symbolic-func.s} {{readelf {-r --wide} symbolic-func.r}}
+	    "symbolic-func.so"}
+    }
 }
 
 set test_list [lsort [glob -nocomplain $srcdir/$subdir/*.d]]
diff --git a/ld/testsuite/ld-elf/symbolic-func.r b/ld/testsuite/ld-elf/symbolic-func.r
new file mode 100644
index 0000000..174e76f
--- /dev/null
+++ b/ld/testsuite/ld-elf/symbolic-func.r
@@ -0,0 +1,18 @@
+# Most targets will emit an R_*_RELATIVE reloc here, but RELATIVE
+# relocs are superfluous.  A target can do without them by simply
+# defining an ADDR32 or ADDR64 style reloc without a symbol to behave
+# like a RELATIVE reloc.  GLOB_DAT relocs are similarly superfluous.
+# In fact, a RELATIVE reloc can be wrong even if a target does have
+# them, if the 32-bit or 64-bit field being relocated is unaligned.
+# In that case the target ought to emit a UADDR32/64 or similar rather
+# than a RELATIVE reloc.
+#
+# We also allow a dynamic reloc with a reference to .text as that
+# should also resolve correctly.  No reloc, or one referencing "fun"
+# is incorrect.  Also fail the test on finding a reloc at offset 0,
+# typically a NONE reloc.
+
+Relocation section.*
+ *Offset.*
+0*[1-9a-f][0-9a-f]* +[^ ]+ +[^ ]+ +([0-9a-f]+( +\.text( \+ 0)?)?)?
+#pass
diff --git a/ld/testsuite/ld-elf/symbolic-func.s b/ld/testsuite/ld-elf/symbolic-func.s
new file mode 100644
index 0000000..29f4138
--- /dev/null
+++ b/ld/testsuite/ld-elf/symbolic-func.s
@@ -0,0 +1,13 @@
+	.text
+	.global fun
+	.type	fun, %function
+fun:
+	.space	4
+	.size	fun, .-fun
+
+	.section .data.rel.ro,"aw",%progbits
+	.p2align 3
+	.type	fun_ptr, %object
+fun_ptr:
+	.dc.a	fun
+	.size	fun_ptr, .-fun_ptr
-- 
1.9.4

